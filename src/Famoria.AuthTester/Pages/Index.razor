@page "/"
@using Microsoft.JSInterop  
@using System.Text.Json  
@implements IAsyncDisposable

<h1>Auth Tester</h1>

<div class="auth-container">
    <button class="signin-button" @onclick="SignIn" disabled="@_isSigningIn">
        @if (_isSigningIn)
        {
            <span>Signing in...</span>
        }
        else
        {
            <span>Sign in with Google</span>
        }
    </button>

    @if (!string.IsNullOrEmpty(_token))
    {
        <button class="link-button" @onclick="LinkGmail" disabled="@_isLinking">
            @if (_isLinking)
            {
                <span>Linking...</span>
            }
            else
            {
                <span>Link Gmail</span>
            }
        </button>
    }

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="error-message">
            <p>@_errorMessage</p>
        </div>
    }
    @if (!string.IsNullOrEmpty(_linkMessage))
    {
        <div class="success-message">
            <p>@_linkMessage</p>
        </div>
    }
    @if (!string.IsNullOrEmpty(_familyId))
    {
        <div class="success-message">
            <p>Signed in successfully!</p>
            <p>Family ID: @_familyId</p>
        </div>
    }
</div>

@code {  
    private string? _token;
    private string? _familyId;
    private string? _errorMessage;
    private bool _isSigningIn = false;
    private bool _isLinking = false;
    private string? _linkMessage;
    private IJSObjectReference? _popup;
    private IJSObjectReference? _linkPopup;
    private DotNetObjectReference<Index>? _objRef;

    protected override void OnInitialized()
    {
        _objRef = DotNetObjectReference.Create(this);
    }

    private async Task SignIn()
    {
        try
        {
            _isSigningIn = true;
            _errorMessage = null;
            StateHasChanged();

            var url = Navigation.ToAbsoluteUri("/auth/signin/google");
            _popup = await JS.InvokeAsync<IJSObjectReference>("open", url, "google-signin", "width=500,height=600,resizable=yes");
            
            // Add event listener for messages from the popup
            await JS.InvokeVoidAsync("window.addEventListener", "message", _objRef, nameof(OnMessage));
            
            // Start a timer to check if popup was closed without completing auth
            await StartPopupClosedCheck();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error initiating sign-in: {ex.Message}";
            _isSigningIn = false;
            StateHasChanged();
        }
    }

    private async Task LinkGmail()
    {
        try
        {
            _isLinking = true;
            _linkMessage = null;
            StateHasChanged();

            var url = Navigation.ToAbsoluteUri("/auth/link/gmail");
            _linkPopup = await JS.InvokeAsync<IJSObjectReference>("open", url, "gmail-link", "width=500,height=600,resizable=yes");

            await JS.InvokeVoidAsync("window.addEventListener", "message", _objRef, nameof(OnMessage));

            for (int i = 0; i < 120; i++)
            {
                await Task.Delay(1000);
                try
                {
                    var closed = await JS.InvokeAsync<bool>("popupIsClosed", _linkPopup);
                    if (closed)
                        break;
                }
                catch { break; }
            }

            if (string.IsNullOrEmpty(_linkMessage))
                _linkMessage = "Link cancelled";
        }
        catch (Exception ex)
        {
            _linkMessage = $"Link failed: {ex.Message}";
        }
        finally
        {
            _isLinking = false;
            try
            {
                await JS.InvokeVoidAsync("window.removeEventListener", "message", _objRef, nameof(OnMessage));
            }
            catch { }
            StateHasChanged();
        }
    }

    private async Task StartPopupClosedCheck()
    {
        // Check every second if popup is closed
        for (int i = 0; i < 120; i++) // 2 minute timeout
        {
            await Task.Delay(1000);
            
            try
            {
                // Check if popup is closed
                var closed = await JS.InvokeAsync<bool>("popupIsClosed", _popup);
                if (closed && string.IsNullOrEmpty(_familyId))
                {
                    await CleanupAuth("Sign-in was cancelled or timed out.");
                    break;
                }
            }
            catch
            {
                // If we can't access the popup, it's likely closed
                if (string.IsNullOrEmpty(_familyId))
                {
                    await CleanupAuth("Sign-in window was closed.");
                }
                break;
            }
        }
    }

    private async Task CleanupAuth(string? errorMessage = null)
    {
        // Remove event listener
        if (_objRef != null)
        {
            try
            {
                await JS.InvokeVoidAsync("window.removeEventListener", "message", _objRef, nameof(OnMessage));
            }
            catch { /* Ignore errors during cleanup */ }
        }
        
        _isSigningIn = false;
        _isLinking = false;
        if (errorMessage != null)
        {
            _errorMessage = errorMessage;
        }
        
        StateHasChanged();
    }

    [JSInvokable]  
    public async Task OnMessage(JsonElement element)  
    {  
        try
        {
            if (element.TryGetProperty("token", out var t))
            {
                var token = t.GetString();
                string? familyId = null;
                if (element.TryGetProperty("familyId", out var f))
                    familyId = f.GetString();

                if (!string.IsNullOrEmpty(token))
                {
                    await JS.InvokeVoidAsync("sessionStorage.setItem", "token", token);
                    _token = token;
                    _familyId = familyId;
                    await CleanupAuth();
                }
                else
                {
                    await CleanupAuth("Received invalid authentication data.");
                }
            }
            else if (element.TryGetProperty("gmail", out var g))
            {
                _linkMessage = g.GetString();
                _isLinking = false;
                try
                {
                    await JS.InvokeVoidAsync("window.removeEventListener", "message", _objRef, nameof(OnMessage));
                }
                catch { }
                StateHasChanged();
            }
            else if (element.TryGetProperty("error", out var e))
            {
                _errorMessage = e.GetString();
                _isSigningIn = false;
                _isLinking = false;
                try
                {
                    await JS.InvokeVoidAsync("window.removeEventListener", "message", _objRef, nameof(OnMessage));
                }
                catch { }
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            await CleanupAuth($"Error processing authentication: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Clean up resources
        if (_objRef != null)
        {
            try
            {
                await JS.InvokeVoidAsync("window.removeEventListener", "message", _objRef, nameof(OnMessage));
            }
            catch { /* Ignore errors during disposal */ }
            
            _objRef.Dispose();
        }
    }

    [Inject] private NavigationManager Navigation { get; set; } = default!;  
    [Inject] private IJSRuntime JS { get; set; } = default!;  
}
